use crate::lang::*;

grammar;

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
    _
}

// Syntax

pub Syntax: Syntax = <a: Let> => a;

Let: Syntax = {
    "let" <n: Ident> ":" <t: ValueType> "=" <l: Let> "in" <r: Let> => Syntax::Let(t.into(), n, l.into(), r.into()),
    "if" <a: Let> "then" <b: Let> "else" <c: Let> => Syntax::Alt(a.into(), b.into(), c.into()),
    <s: Func> => s,
}

Func: Syntax = {
    "(" <n: Ident> ":" <t: ValueType> ")" "=>" <s: Syntax> => Syntax::Func(t.into(), n, s.into()),
    <s: CmpExpr> => s,
}

CmpExpr: Syntax = {
    <l: CmpExpr> "<" <r: AddExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Lt).into(), l.into()).into(), r.into()),
    <l: CmpExpr> ">" <r: AddExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Gt).into(), l.into()).into(), r.into()),
    <l: CmpExpr> "<=" <r: AddExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Le).into(), l.into()).into(), r.into()),
    <l: CmpExpr> ">=" <r: AddExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Ge).into(), l.into()).into(), r.into()),
    <l: AddExpr> => l,
}

AddExpr: Syntax = {
    <l: AddExpr> "+" <r: MulExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Add).into(), l.into()).into(), r.into()),
    <l: AddExpr> "-" <r: MulExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Sub).into(), l.into()).into(), r.into()),
    <l: MulExpr> => l,
}

MulExpr: Syntax = {
    <l: MulExpr> "*" <r: UnaryExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Mul).into(), l.into()).into(), r.into()),
    <l: MulExpr> "/" <r: UnaryExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Div).into(), l.into()).into(), r.into()),
    <l: UnaryExpr> => l,
}

UnaryExpr: Syntax = {
    "-" <x: UnaryExpr> => Syntax::Apply(Syntax::Apply(Syntax::Extern(Extern::Sub).into(), Syntax::Float(0.0).into()).into(), x.into()),
    <x: Apply> => x,
}

Apply: Syntax = {
    <l: Apply> "(" <r: Syntax> ")" => Syntax::Apply(l.into(), r.into()),
    <l: Atom> => l,
}

Atom: Syntax = {
    <n: Float> => Syntax::Float(n),
    <n: Bool> => Syntax::Bool(n),
    <i: Ident> => Syntax::Var(i),
    "(" <t: Syntax> ")" => t,
}

// Value Type

ValueType: ValueType = <a: TFunc> => a;

TFunc: ValueType = {
    <f: TAtom> "->" <t: TFunc> => ValueType::Func(f.into(), t.into()),
    <a: TAtom> => a,
}

TAtom: ValueType = {
    "Float" => ValueType::Float,
    "Bool" => ValueType::Bool,
    "(" <t: ValueType> ")" => t,
}

// Literals

Ident: String = <s: r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_string();

Float: f32 = {
    <s: r"0|[1-9][0-9]*"> => s.parse::<f32>().unwrap(),
    <s: r"[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?"> => s.parse::<f32>().unwrap(),
    <s: r"[0-9]+\.([eE][+-]?[0-9]+)?"> => s.parse::<f32>().unwrap(),
    <s: r"[0-9]+[eE][+-]?[0-9]+"> => s.parse::<f32>().unwrap(),
}

Bool: bool = {
    "true" => true,
    "false" => false,
}